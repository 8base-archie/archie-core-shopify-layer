package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"archie-core-shopify-layer/graph/generated"
	"archie-core-shopify-layer/graph/model"
	"archie-core-shopify-layer/graph/scalars"
	"archie-core-shopify-layer/internal/application"
	"context"
	"fmt"
	"time"
)

// ConfigureShopify is the resolver for the configureShopify field.
func (r *mutationResolver) ConfigureShopify(ctx context.Context, input model.ConfigureShopifyInput) (*model.ConfigureShopifyPayload, error) {
	tenantID := getTenantID(ctx)
	if tenantID == "" {
		return nil, fmt.Errorf("tenant ID not found in context")
	}

	configInput := &application.ConfigureShopifyInput{
		APIKey:        input.APIKey,
		APISecret:     input.APISecret,
		WebhookSecret: "",
	}
	if input.WebhookSecret != nil {
		configInput.WebhookSecret = *input.WebhookSecret
	}

	config, err := r.credentialsService.ConfigureShopify(ctx, tenantID, configInput)
	if err != nil {
		return nil, err
	}

	return &model.ConfigureShopifyPayload{
		ID:         config.ID,
		APIKey:     config.APIKey,
		WebhookURL: config.WebhookURL,
	}, nil
}

// ShopifyInstallApp is the resolver for the shopify_installApp field.
func (r *mutationResolver) ShopifyInstallApp(ctx context.Context, input model.InstallAppInput) (*model.InstallAppPayload, error) {
	authURL, err := r.shopifyService.GenerateAuthURL(ctx, input.Shop, input.Scopes)
	if err != nil {
		return nil, err
	}

	return &model.InstallAppPayload{
		AuthURL: authURL,
	}, nil
}

// ShopifyExchangeToken is the resolver for the shopify_exchangeToken field.
func (r *mutationResolver) ShopifyExchangeToken(ctx context.Context, input model.ExchangeTokenInput) (*model.ExchangeTokenPayload, error) {
	shop, err := r.shopifyService.ExchangeToken(ctx, input.Shop, input.Code)
	if err != nil {
		return nil, err
	}

	return &model.ExchangeTokenPayload{
		Shop: &model.Shop{
			ID:        shop.ID,
			Domain:    shop.Domain,
			Scopes:    shop.Scopes,
			CreatedAt: scalars.Time(shop.CreatedAt),
			UpdatedAt: scalars.Time(shop.UpdatedAt),
		},
		AccessToken: shop.AccessToken,
	}, nil
}

// ShopifyConfigureCredentials is the resolver for the shopify_configureCredentials field (deprecated).
func (r *mutationResolver) ShopifyConfigureCredentials(ctx context.Context, input model.ConfigureCredentialsInput) (*model.ConfigureCredentialsPayload, error) {
	tenantID := getTenantID(ctx)
	if tenantID == "" {
		// Fallback to input projectId for backward compatibility
		tenantID = input.ProjectID
	}

	configInput := &application.ConfigureShopifyInput{
		APIKey:        input.APIKey,
		APISecret:     input.APISecret,
		WebhookSecret: "",
	}

	config, err := r.credentialsService.ConfigureShopify(ctx, tenantID, configInput)
	if err != nil {
		return nil, err
	}

	// Convert to legacy format
	creds := &model.ShopifyCredentials{
		ID:          config.ID,
		ProjectID:   config.ProjectID,
		Environment: config.Environment,
		APIKey:      config.APIKey,
		CreatedAt:   scalars.Time(config.CreatedAt),
		UpdatedAt:   scalars.Time(config.UpdatedAt),
	}

	return &model.ConfigureCredentialsPayload{
		Credentials: creds,
	}, nil
}

// ShopifyDeleteCredentials is the resolver for the shopify_deleteCredentials field.
func (r *mutationResolver) ShopifyDeleteCredentials(ctx context.Context, projectID string, environment string) (bool, error) {
	// TODO: Implement delete functionality
	return false, fmt.Errorf("delete credentials not yet implemented")
}

// ShopifyShop is the resolver for the shopify_shop field.
func (r *queryResolver) ShopifyShop(ctx context.Context, domain string) (*model.Shop, error) {
	shop, err := r.shopifyService.GetShop(ctx, domain)
	if err != nil {
		return nil, err
	}

	if shop == nil {
		return nil, nil
	}

	return &model.Shop{
		ID:        shop.ID,
		Domain:    shop.Domain,
		Scopes:    shop.Scopes,
		CreatedAt: scalars.Time(shop.CreatedAt),
		UpdatedAt: scalars.Time(shop.UpdatedAt),
	}, nil
}

// ShopifyProducts is the resolver for the shopify_products field.
func (r *queryResolver) ShopifyProducts(ctx context.Context, domain string) ([]*model.Product, error) {
	products, err := r.shopifyService.GetProducts(ctx, domain)
	if err != nil {
		return nil, err
	}

	result := make([]*model.Product, len(products))
	for i, p := range products {
		createdAt, _ := time.Parse(time.RFC3339, p.CreatedAt.String())
		updatedAt, _ := time.Parse(time.RFC3339, p.UpdatedAt.String())

		result[i] = &model.Product{
			ID:          fmt.Sprintf("%d", p.Id),
			Title:       p.Title,
			Handle:      &p.Handle,
			Vendor:      &p.Vendor,
			ProductType: &p.ProductType,
			CreatedAt:   scalars.Time(createdAt),
			UpdatedAt:   scalars.Time(updatedAt),
		}
	}

	return result, nil
}

// ShopifyProduct is the resolver for the shopify_product field.
func (r *queryResolver) ShopifyProduct(ctx context.Context, domain string, productID string) (*model.Product, error) {
	panic(fmt.Errorf("not implemented: ShopifyProduct - shopify_product"))
}

// ShopifyOrders is the resolver for the shopify_orders field.
func (r *queryResolver) ShopifyOrders(ctx context.Context, domain string) ([]*model.Order, error) {
	panic(fmt.Errorf("not implemented: ShopifyOrders - shopify_orders"))
}

// ShopifyOrder is the resolver for the shopify_order field.
func (r *queryResolver) ShopifyOrder(ctx context.Context, domain string, orderID string) (*model.Order, error) {
	panic(fmt.Errorf("not implemented: ShopifyOrder - shopify_order"))
}

// ShopifyCustomers is the resolver for the shopify_customers field.
func (r *queryResolver) ShopifyCustomers(ctx context.Context, domain string) ([]*model.Customer, error) {
	panic(fmt.Errorf("not implemented: ShopifyCustomers - shopify_customers"))
}

// ShopifyCustomer is the resolver for the shopify_customer field.
func (r *queryResolver) ShopifyCustomer(ctx context.Context, domain string, customerID string) (*model.Customer, error) {
	panic(fmt.Errorf("not implemented: ShopifyCustomer - shopify_customer"))
}

// ShopifySearchCustomers is the resolver for the shopify_searchCustomers field.
func (r *queryResolver) ShopifySearchCustomers(ctx context.Context, domain string, query string) ([]*model.Customer, error) {
	panic(fmt.Errorf("not implemented: ShopifySearchCustomers - shopify_searchCustomers"))
}

// ShopifyInventoryLevels is the resolver for the shopify_inventoryLevels field.
func (r *queryResolver) ShopifyInventoryLevels(ctx context.Context, domain string) ([]*model.InventoryLevel, error) {
	panic(fmt.Errorf("not implemented: ShopifyInventoryLevels - shopify_inventoryLevels"))
}

// ShopifyGetConfig is the resolver for the shopify_getConfig field.
func (r *queryResolver) ShopifyGetConfig(ctx context.Context) (*model.ShopifyConfig, error) {
	tenantID := getTenantID(ctx)
	if tenantID == "" {
		return nil, fmt.Errorf("tenant ID not found in context")
	}

	config, err := r.credentialsService.GetConfig(ctx, tenantID)
	if err != nil {
		return nil, err
	}

	return &model.ShopifyConfig{
		ID:          config.ID,
		ProjectID:   config.ProjectID,
		Environment: config.Environment,
		APIKey:      config.APIKey,
		WebhookURL:  config.WebhookURL,
		CreatedAt:   scalars.Time(config.CreatedAt),
		UpdatedAt:   scalars.Time(config.UpdatedAt),
	}, nil
}

// ShopifyGetCredentials is the resolver for the shopify_getCredentials field (deprecated).
func (r *queryResolver) ShopifyGetCredentials(ctx context.Context, projectID string, environment string) (*model.ShopifyCredentials, error) {
	tenantID := getTenantID(ctx)
	if tenantID == "" {
		tenantID = projectID // Fallback
	}

	creds, err := r.credentialsService.GetCredentials(ctx, tenantID, environment)
	if err != nil {
		return nil, err
	}

	if creds == nil {
		return nil, nil
	}

	return &model.ShopifyCredentials{
		ID:          creds.ID,
		ProjectID:   creds.ProjectID,
		Environment: creds.Environment,
		APIKey:      creds.APIKey,
		CreatedAt:   scalars.Time(creds.CreatedAt),
		UpdatedAt:   scalars.Time(creds.UpdatedAt),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
